"""
Authors: Jerom Aerts
Contact: j.p.m.aerts@tudelft.nl

wflow Julia requires netcdf parameter input files which are generated by HydroMT. To use HydroMT parameter sets
with wflow Python this scripts converts netcdf files to PCRaster files.
"""

import pandas as pd
import xarray as xr
import numpy as np
from os.path import join,dirname
import os
import hydromt
import glob
import shutil

# Mapping for PCRaster Types
pcraster_dtypes = {'Kext': 'scalar',
                    'KsatVer': 'scalar',
                    'KsatVer_0': 'scalar',
                    'KsatVer_100': 'scalar',
                    'KsatVer_15': 'scalar',
                    'KsatVer_200': 'scalar',
                    'KsatVer_30': 'scalar',
                    'KsatVer_5': 'scalar',
                    'KsatVer_60': 'scalar',
                    'M': 'scalar',
                    'M_original': 'scalar',
                    'M_original_': 'scalar',
                    'N': 'scalar',
                    'PathFrac': 'scalar',
                    'RiverSlope': 'scalar',
                    'RootingDepth': 'scalar',
                    'Sl': 'scalar',
                    'Slope': 'scalar',
                    'SoilMinThickness': 'scalar',
                    'SoilThickness': 'scalar',
                    'Swood': 'scalar',
                    'WaterFrac': 'scalar',
                    'c_0': 'scalar',
                    'c_1': 'scalar',
                    'c_2': 'scalar',
                    'c_3': 'scalar',
                    'old_M': 'scalar',
                    'rivwth_obs': 'scalar',
                    'subare': 'scalar',
                    'thetaR': 'scalar',
                    'thetaS': 'scalar',
                    'wflow_dem': 'scalar',
                    'wflow_gauges': 'nominal',
                    'wflow_landuse': 'nominal',
                    'wflow_ldd': 'ldd',
                    'wflow_river': 'bool',
                    'wflow_riverlength': 'scalar',
                    'wflow_riverwidth': 'scalar',
                    'wflow_soil': 'nominal',
                    'wflow_streamorder': 'ordinal',
                    'wflow_subcatch': 'nominal',
                    'wflow_uparea': 'scalar',
                    'x_out': 'scalar',
                    'y_out': 'scalar'}

# Specify parameter directory
model_dir = '/gpfs/home6/jaerts/folder/'

model_instances = glob.glob(f'{model_dir}/*')

# Loop model instances and save staticmaps
for instance in model_instances:

    root = instance
    mod = hydromt.WflowModel(root, mode='r')
    ds = mod.staticmaps
    outdir = join(root, 'staticmaps')
    ds.raster.to_mapstack(outdir, driver='PCRaster', pcr_vs_map=pcraster_dtypes)

# Loop model instances and save tables
for instance in model_instances:
    intables = ['cf_soil', 'Cfmax', 'EoverR', 'InfiltCapPath', 'InfiltCapSoil', 'MaxLeakage', 'rootdistpar', 'TT', 'TTI', 'TTM', 'WHC']

    if not os.path.exists(f'{instance}/intbl'):
        os.mkdir(f'{instance}/intbl/')

    for table in intables:
        # print(table)
        ds = xr.open_dataset(f'{instance}/staticmaps.nc')

        if pd.isnull(float(ds[table].max().values)) is True:
            value = 0
        else:
            value = ds[table].max().values

        table_outfile = f'{instance}/intbl/{table}.tbl'

        with open(table_outfile, "w+") as f:
            f.write(f'[0,> [0,> [0,> {value}')
            f.close()

# loop instances and create KsatHorFrac table
for instance in model_instances:
    table = 'KsatHorFrac'
    ds = xr.open_dataset(f'{instance}/staticmaps.nc')

    if pd.isnull(float(ds[table].max().values)) is True:
        value = 0
    else:
        value = ds[table].max().values

    table_outfile = f'{instance}/intbl/{table}.tbl'

    with open(table_outfile, "w+") as f:
        f.write(f'[0,> [0,> [0,> {int(value)}')
        f.close()

# Loop instances and create N_River table
for instance in model_instances:
    table = 'N_River'
    orders = []
    n_values = []

    ds_river = xr.open_dataset(f'{instance}/staticmaps.nc').N_River
    ds_order = xr.open_dataset(f'{instance}/staticmaps.nc').wflow_streamorder

    for order in range(1,9):
        orders.append(order)

        coords = np.argwhere(np.array(ds_order == order))
        if coords.size:
            n_river_value = ds_river[coords[0][0], coords[0][1]].values
            n_values.append(n_river_value)
        else:
            n_river_value = max(n_values)
            n_river_value = np.round(n_river_value, 3)
            n_values.append(n_river_value)
    print(orders)
    print(n_values)
    for i in orders:
        # print(i)
        table_outfile = f'{instance}/intbl/{table}.tbl'

        with open(table_outfile, "a") as f:
            if i == 8:
                f.write(f'[{str(i)},> {str(n_values[i-1])}\n')
            else:
                f.write(f'{str(i)} {str(n_values[i-1])}\n')

# Loop instances and create monthly LAI maps
for instance in model_instances:
    if not os.path.exists(f'{instance}/staticmaps/clim/'):
        os.mkdir(f'{instance}/staticmaps/clim/')
    lai_files = glob.glob(f'{instance}/staticmaps/LAI00000.0*')

    for file in lai_files:
        shutil.copyfile(file, f'{instance}/staticmaps/clim/{os.path.basename(file)}')

# Loop instances and rename c staticmaps
for instance in model_instances:    
    
    os.rename(f'{instance}/staticmaps/c0000000.001', f'{instance}/staticmaps/c_0.map')
    os.rename(f'{instance}/staticmaps/c0000000.002', f'{instance}/staticmaps/c_1.map')
    os.rename(f'{instance}/staticmaps/c0000000.003', f'{instance}/staticmaps/c_2.map')
    os.rename(f'{instance}/staticmaps/c0000000.004', f'{instance}/staticmaps/c_3.map')

    os.rename(f'{instance}/staticmaps/KsatHorFrac.map', f'{instance}/staticmaps/old_KsatHorFrac.map')
    if not os.path.exists(f'{instance}/inmaps'):
        os.mkdir(f'{instance}/inmaps')